package mountain;

import java.util.HashMap;

import fractal.Fractal;
import fractal.TurtleGraphics;

public class MountainSide extends Fractal {
	private Point a;
	private Point b;
	private Point c;
	private HashMap<Side, Point> smap = new HashMap<Side, Point>();

	public MountainSide(Point a, Point b, Point c) {
		super();
		this.a = a;
		this.b = b;
		this.c = c;
		// smap.put(ab, middle(ab.getP1(), ab.getP2(),10.0));
		// smap.put(bc, middle(bc.getP1(), bc.getP2(),10.0));
		// smap.put(ca, middle(ca.getP1(), ca.getP2(),10.0));

	}

	@Override
	public String getTitle() {
		return "Mountain";
	}

	// D5
	public void draw(TurtleGraphics turtle) {
		fractalTriangle(turtle, order, a, b, c, 10.0);
	}

	public void fractalTriangle(TurtleGraphics turtle, int order, Point p1, Point p2, Point p3, double d) {
		if (order == 0) {
			turtle.moveTo(p1.getX(),p1.getY());
			turtle.penDown(); // is set as true when creating a turtle, just for
								// backup.
			turtle.forwardTo(p2.getX(),p2.getY());
			turtle.forwardTo(p3.getX(),p3.getY());
			turtle.forwardTo(p1.getX(),p1.getY());
		} else {
			// change the points to the new values, i.e. the middle of where
			// point a meets point b
			// cast randfunc in randomutilities to int. (Point only accepts
			// integers)
			// Draw new triangles (4)
			Point AmB = middle(p1,p2,d);
			Point BmC = middle(p2,p3,d);
			Point CmA = middle(p3,p1,d);
			
			smap.forEach((k,v) ->{
				if(k.getP1().equals(p1) || k.equals(p2) || k.equals(p3)){
					
				}
			});
			
			if (smap.containsKey(a)) {
				AmB = new Side(a.getP1(), smap.get(a));
				smap.remove(a);
			} else {
				AmB = new Side(a.getP1(), middle(a.getP1(), a.getP2(),d));
				smap.put(AmB, middle(AmB.getP1(), AmB.getP2(),d/2));
			}
			
			if (smap.containsKey(b)) {
				BmC = new Side(b.getP1(), smap.get(b));
				smap.remove(b);
			} else {
				BmC = new Side(b.getP1(), middle(b.getP1(), b.getP2(),d));
				smap.put(BmC, middle(BmC.getP1(), BmC.getP2(),d));
			}
			
			if (smap.containsKey(c)) {
				CmA = new Side(c.getP1(), smap.get(c));
				smap.remove(c);
			} else {
				CmA = new Side(c.getP1(), middle(c.getP1(), c.getP2(),d));
				smap.put(CmA, middle(CmA.getP1(), CmA.getP2(),d));
			}
			
			fractalTriangle(turtle, order - 1, AmB, BmC, CmA, d / 2);
			fractalTriangle(turtle, order - 1, AmB, CmA, a, d / 2);
			fractalTriangle(turtle, order - 1, AmB, b, BmC, d / 2);
			fractalTriangle(turtle, order - 1, BmC, c, CmA, d / 2);
		}
	}

	private Point middle(Point p1, Point p2, double d) {
		return new Point((p1.getX() + p2.getX()) / 2, ((p1.getY() + p2.getY()) / 2 + (int)RandomUtilities.randFunc(d)));
	}
}
